这道题刚看的时候没有任何思路，就先写了排序算法，将输入的无序的position数组排为有序数组。
拍好之后，由于相邻的两个球的距离不一定为1，因此想到用二分法查找最左和最右的两个球之间，最中间的球的位置，
例如，position = [5,4,3,2,1,1000000000]，排序后，position = [1,2,3,4,5,1000000000]，此时第一个球位置为1，最后一个球位置为1000000000，这两个球最中间的位置应是500000000，然而这个位置没有球，那么就返回中间最接近的球，即位置为5的球
但这种思路只适用于m<=3的情况，对于更复杂的情况仍然不可行。

上面的思路想到了排序+二分查找。那么换个思路，不再二分位置，转向二分距离。
二分距离初始情况下，最小距离low=1，最大距离high=position[position.length-1]-position[0]，mid=(high-low)>>1
接下来进入循环,不断检测position数组中是否存在距离为mid的m个球，存在或不存在，均用二分法缩小范围，不断循环，直到low>=high。
