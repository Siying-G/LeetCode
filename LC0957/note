  看到该题目，最简单的想法是两个for循环，外面的循环天数，里面的循环牢房状态。但这个想法过于暴力，一定会出现超时的情况。本着不死心的心态，还是写了一版暴力求解，如LC0957_V1
  提交了一次，果然超时了。换一种想法，既然样例二能给出如此大的天数，那么大概率牢房状态存在某种循环，打印了几个状态，果然发现了循环，状态每14天为一循环，于是给LC0957_V1加上了天数取模的操作。这里有一个问题是对14取模，那么天数到14的倍数时，取模后为0.于是取模应写成：n = (n%14 == 0) ? 14 : n%14;
  第二版（如LC0957_V2）提交通过后，查看了官方代码，发现官方代码的思路更为奇妙（如LC0957_V3），将牢房状态看成二进制数字，先将其转为十进制数字作为key，天数作为value存储进map数据结构。每产生一个新的牢房状态，就先将其转十进制，再查询map中是否有该key，若有，即表示产生了循环状态，不用再重新计算，天数取余读取即可。
