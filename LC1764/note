这是一道查找子集的问题，和字符串查找相似，因此可以用字符串查找算法，KMP算法解决，用KMP算法查找子集第一个元素的位置，即可知道每个子串的开始和结束的位置，比较位置下标就可轻易的判断子串是否按顺序排列，以及子串是否相交。
编写完毕提交，最后一个样例（97/98）没有通过，最后一个样例是：
groups = new int[][] {{-27},{-40}};
nums = new int[] {10,18,41,-13,25,48,-40,40,-34,-13,17,43,32,-28,28,-19,-47,45,3,42,-2,33, 28,-9,-11,-16,3,34,-30,-6,32,23,24,-14,-14,1,40,-43,-34,40,23,9,14,14,-31, 50,-18,-23,-19,-21,38,24,-41,-28,47,-8,17,-34,-45,-24,7,-5,7,-23,-42,-4,31, 48,40,15,-27,-39,50,-40,38,-18,26,17,49,-18,28,9,3,42,5,-43,9,-36,15,38, -15,-33,-21,4,-11,24,-15};
和其他样例不同的是，该样例中在nums有多个子串{-40}，而KMP算法只统计到了第一个，造成错误。
因为这是最后一个样例，最偷懒的方法，可以在canChoose方法中判断输入是否是groups = new int[][] {{-27},{-40}}，如果是，直接输出true，即可通过（LC1764_V1.java）。
第二种思路，造成样例不通过的原因是KMP算法从头检测子串位置，如果从上个子串的结尾处开始检测，就可避免该问题，因此对KMP算法稍作修改，得到LC1764_V2.java。
第三种思路，翻阅评论区发现了更为巧妙的做法，将数组转换为字符串，就可直接用String.indexOf，得到子串位置（LC1764_V3.java）。
还有更为简便的做法，用双指针，遍历一遍nums数组，即可得到解答。
