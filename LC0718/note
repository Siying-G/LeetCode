这是一道动态规划题目。
刚看到题目时没有想到动态规划，就硬着头皮写了暴力求解（LC0718_V1.java），果然运行超时。
由于写这道题时是第一次接触动态规划，苦思冥想得不到题解，因此查看评论区的做法，用一个二维数组dp表示状态转移矩阵，数组(i,j)位置的数代表以nums1[i]和nums2[j]结束的共同子数组长度，显然若nums1[i]不等于nums2[j]，dp[i][j]=0.
为了后续表示方便，防止数组下标不合法，因此初始化dp数组为(nums1.length,nums2.length)尺寸。并初始化为全0数组。
接下来需要使用内外嵌套的接下来需要使用内外嵌套的两个for循环，从下标1开始遍历两个数组若nums1[i]== nums2[j]，表示可以给已有的子数组的长度+1，也就是给dp[i][j]。通过不断循环，更新dp数组，dp数组中最大的数即为所求的最长重复子数组的长度。
