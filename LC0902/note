这道题目为“hard”难度
初看感觉思路很简单，认为利用二分查找找出每位数的可能取值情况数，再依次相乘即可（LC0902_V1.java）。显然，这种思路过于简单，没有考虑很多特殊情况
2021.9.15记录：
第二次，利用递归思路，假设输入的数字n是K位数，先计算小于K位数的情况。再计算K位数的情况：
假设n的最高位为a，此时如果digits[0]>a，此时不存在K位数，即可结束。
如果digits[0]=a，那么最高位只有一种情况即digits[0]，次高位需要递归判断。
如果digits[0]>a,那么最高位的情况数可用二分法查找出来，返回查找的情况数*递归除去最高位剩下的位数
但该想法只能通过一半的样例，仍需后续思考
